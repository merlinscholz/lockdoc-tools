<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="pandoc.css" />
</head>
<body>
<!-- MarkdownTOC -->
<ul>
<li><a href="#vorbereitung-und-installation-von-freebsd-unter-qemu">Vorbereitung und Installation von FreeBSD unter QEMU</a>
<ul>
<li><a href="#vorbereitung">Vorbereitung</a></li>
<li><a href="#installation">Installation</a>
<ul>
<li><a href="#booten">Booten</a></li>
<li><a href="#beginn-der-installation">Beginn der Installation</a></li>
<li><a href="#keyboard-konfiguration">Keyboard konfiguration</a></li>
<li><a href="#konfiguration">Konfiguration</a></li>
<li><a href="#partitionierung">Partitionierung</a></li>
<li><a href="#eigentliche-installation">Eigentliche Installation</a></li>
<li><a href="#root-passwort">Root-Passwort</a></li>
<li><a href="#netzwerk">Netzwerk</a></li>
<li><a href="#zeiteinstellung">Zeiteinstellung</a></li>
<li><a href="#services">Services</a></li>
<li><a href="#hardening">Hardening</a></li>
<li><a href="#weitere-benutzer">Weitere Benutzer</a></li>
<li><a href="#abschluss">Abschluss</a></li>
<li><a href="#fertiges-os">Fertiges OS</a></li>
<li><a href="#links">Links</a></li>
</ul></li>
</ul></li>
<li><a href="#freebsd-f%C3%BCr-lockdoc-vorbereiten">FreeBSD für LockDoc vorbereiten</a>
<ul>
<li><a href="#erforderliche-pakete-installieren">Erforderliche Pakete installieren</a></li>
<li><a href="#userland-einrichten">Userland einrichten</a></li>
<li><a href="#userland-compilieren">Userland aus dem Repository installieren</a></li>
<li><a href="#installation-des-init-skripts">Installation des Init-Skripts</a></li>
<li><a href="#installation-des-benchmark-skripts">Installation des Benchmark-Skripts</a></li>
<li><a href="#installation-der-benchmark-tools">Installation der Benchmark-Tools</a></li>
<li><a href="#konfiguration-und-%C3%9Cbersetzen-des-freebsd-kernels">Konfiguration und Übersetzen des FreeBSD Kernels</a>
<ul>
<li><a href="#konfiguration-1">Konfiguration</a></li>
<li><a href="#%C3%9Cbersetzen-au%C3%9Ferhalb-des-source-trees">Übersetzen außerhalb des Source-Trees</a></li>
<li><a href="#%C3%9Cbersetzen-im-source-tree">Übersetzen im Source-Tree</a></li>
</ul></li>
<li><a href="#links-1">Links</a></li>
</ul></li>
<li><a href="#freebas-code-abdeckung">Code-Abdeckung</a>
<ul>
<li><a href="#freebsd-code-abdeckung-bestimmen-gcov">Code-Abdeckung bestimmen - GCOV</a></li>
<li><a href="#freebsd-code-abdeckung-bestimmen-kcov">Code-Abdeckung bestimmen - KCOV</a></li>
<li><a href="#freebsd-code-abdeckung-links">Links</a></li>
</ul></li>
</ul>
<!-- /MarkdownTOC -->
<p><a id="vorbereitung-und-installation-von-freebsd-unter-qemu"></a></p>
<h1 id="vorbereitung-und-installation-von-freebsd-unter-qemu">Vorbereitung und Installation von FreeBSD unter QEMU</h1>
<p><a id="vorbereitung"></a></p>
<h2 id="vorbereitung">Vorbereitung</h2>
<p>Zunächst laden wir ein Installer-Image von <a href="https://www.freebsd.org/where.html">freebsd.org/where.html</a> herunter. Wir verwenden das DVD-Image für <a href="https://download.freebsd.org/ftp/releases/i386/i386/ISO-IMAGES/12.2/FreeBSD-12.2-RELEASE-i386-dvd1.iso">FreeBSD 12.2</a> für i386.</p>
<p>Danach erstellen wir entsprechend der geladenen Version ein VM-Image:</p>
<p><code>qemu-img create -f raw freebsd.img 25G</code></p>
<p>QEMU kann manuel gestartet werden:</p>
<p><code>qemu-system-x86_64 -smp 1 -boot c -cdrom /path/to/FreeBSD-12.2-RELEASE-i386-dvd1.iso -m 512 -hda /path/to/freebsd.img</code></p>
<p>Alternativ kann man die virtuelle Maschine via Virt-Manager erstellen.</p>
<p><a id="installation"></a></p>
<h2 id="installation">Installation</h2>
<p><a id="booten"></a></p>
<h3 id="booten">Booten</h3>
<p>Wir booten das Installer-Image in den gewünschten Modus. Der Standardfall ist dabei <code>multi user</code>. Zu den Modis siehe auch <a href="https://www.freebsd.org/doc/handbook/boot-introduction.html#boot-singleuser">FreeBSD Handbook</a>.</p>
<p><img src="./img/install-01.png" alt="alt text" /></p>
<p><a id="beginn-der-installation"></a></p>
<h3 id="beginn-der-installation">Beginn der Installation</h3>
<p>Danach wählen wir <code>Install</code> aus, um die Installation zu beginnen.</p>
<p><img src="./img/install-02.png" alt="alt text" /></p>
<p><a id="keyboard-konfiguration"></a></p>
<h3 id="keyboard-konfiguration">Keyboard konfiguration</h3>
<p>Konfiguration des Tastatur Layouts (Default ist US).</p>
<p><img src="./img/install-03.png" alt="alt text" /></p>
<p>Wir haben <em>German</em> gewählt.</p>
<p><img src="./img/install-04.png" alt="alt text" /></p>
<p><a id="konfiguration"></a></p>
<h3 id="konfiguration">Konfiguration</h3>
<p>Danach geben wir der Maschine einen Namen.</p>
<p><img src="./img/install-05.png" alt="alt text" /></p>
<p>Und haben nun die Auswahl darüber, was installiert werden soll. Entgegen des Screenshots ist das Paket <code>src</code> nicht erforderlich, da wir unseren eigenen FreeBSD-Tree nutzen. Ansonsten ist noch die Option <code>ports</code> zu erwähnen, die eine Ansammlung von Scripten entspricht, die automatisiert Software (z.B. X11), die nicht direkt zu FreeBSD gehört, laden, übersetzt und installiert. Der Rest sollte selbsterklärend sein.</p>
<p>Die Komponenten lassen sich auch alle nachträglich installieren.</p>
<p><img src="./img/install-06.png" alt="alt text" /></p>
<p><a id="partitionierung"></a></p>
<h3 id="partitionierung">Partitionierung</h3>
<p>Anschließend partitionieren wir unser VM-Image. Hier wird <code>UFS</code> als Dateisystem gewählt.</p>
<p><img src="./img/install-07.png" alt="alt text" /> <img src="./img/install-08.png" alt="alt text" /> <img src="./img/install-09.png" alt="alt text" /> <img src="./img/install-10.png" alt="alt text" /> <img src="./img/install-11.png" alt="alt text" /></p>
<p><a id="eigentliche-installation"></a></p>
<h3 id="eigentliche-installation">Eigentliche Installation</h3>
<p>Jetzt kopiert und entpackt der Installer die Daten von dem Installer-Image auf das VM-Image. Das kann je nach Maschine und Installer-Image 3-10 Minuten dauern.</p>
<p><img src="./img/install-12.png" alt="alt text" /></p>
<p><a id="root-passwort"></a></p>
<h3 id="root-passwort">Root-Passwort</h3>
<p>Jetzt noch das root-Passwort festlegen und wir sind fast fertig.</p>
<p><img src="./img/install-15.png" alt="alt text" /></p>
<p><a id="netzwerk"></a></p>
<h3 id="netzwerk">Netzwerk</h3>
<p>Entsprechende Netzwerk Einstellungen sind nur notwendig, falls Software (z.B. <code>vim</code>) nachinstalliert werden soll oder falls für die eigentliche Aufgabe Netzwerk notwendig ist.</p>
<p><img src="./img/install-16.png" alt="alt text" /> <img src="./img/install-17.png" alt="alt text" /> <img src="./img/install-18.png" alt="alt text" /> <img src="./img/install-19.png" alt="alt text" /></p>
<p>IPv6 können wir überspringen, da die Uni (und das ITMC) eh nicht daran glauben.</p>
<p><img src="./img/install-20.png" alt="alt text" /></p>
<p>Die DNS Einstellungen kann man auf den voreingestellten Werten belassen.</p>
<p><img src="./img/install-21.png" alt="alt text" /></p>
<p><a id="zeiteinstellung"></a></p>
<h3 id="zeiteinstellung">Zeiteinstellung</h3>
<p><img src="./img/install-22.png" alt="alt text" /> <img src="./img/install-23.png" alt="alt text" /> <img src="./img/install-24.png" alt="alt text" /> <img src="./img/install-25.png" alt="alt text" /></p>
<p>Falls notwendig setzen des korrekten Datums und Uhrzeit.</p>
<p><img src="./img/install-26.png" alt="alt text" /> <img src="./img/install-27.png" alt="alt text" /></p>
<p><a id="services"></a></p>
<h3 id="services">Services</h3>
<p>Hier kann der Default auch belassen werden. <code>sshd</code> ist natürlich empfehlenswert.</p>
<p><img src="./img/install-28.png" alt="alt text" /></p>
<p><a id="hardening"></a></p>
<h3 id="hardening">Hardening</h3>
<p><img src="./img/install-29.png" alt="alt text" /></p>
<p><a id="weitere-benutzer"></a></p>
<h3 id="weitere-benutzer">Weitere Benutzer</h3>
<p>Hier sollte direkt ein Nutzer angelegt werden. Analog zu Linux können wir später jeder Zeit neue Nutzer mit <code>adduser</code> anlegen.</p>
<p><img src="./img/install-30.png" alt="alt text" /></p>
<p><a id="abschluss"></a></p>
<h3 id="abschluss">Abschluss</h3>
<p>Im Anschluss haben wir noch einmal die Möglichkeit diverse Einstellungen zu ändern. <img src="./img/install-31.png" alt="alt text" /></p>
<p>Außerdem erhalten wir noch die Option vor dem Neustart mit einer Shell im neuen System eigene Änderungen vorzunehmen. Hier empfhielt es sich, für die erstellten Partitionen bzw. Slices Labels zu vergeben. So kann man in QEMU z.B. den VirtIO-Treiber für die Festplattenemulation nutzen und gleichzeitig in BOCHS eine IDE-Platte emulieren. Wichtig ist, dass in diesem Schritt <strong>nur</strong> die Labels vergeben werden. Die Änderungen an der <code>/etc/fstab</code> sollten später <strong>nach</strong> einem Neutstart erfolgen.</p>
<pre><code>glabel label swap /dev/XXX
tunefs -L roots /dev/XXX</code></pre>
<p><strong>Achtung:</strong> Das Tool <code>glabel</code> darf <strong>nur</strong> für Partitionen, die kein Dateisystem beinhalten, wie z.B. die swap-Partition, genutzt werden. Für Dateisysteme, wie z.B. UFS, ist <code>tunefs</code> zu nehmen. <img src="./img/install-32.png" alt="alt text" /> <img src="./img/install-33.png" alt="alt text" /> <img src="./img/install-34.png" alt="alt text" /></p>
<p><a id="fertiges-os"></a></p>
<h3 id="fertiges-os">Fertiges OS</h3>
<p>Nach dem Neustart können wir uns anmelden:</p>
<p><img src="./img/install-35.png" alt="alt text" /> <img src="./img/install-36.png" alt="alt text" /> <img src="./img/install-37.png" alt="alt text" /></p>
<p><a id="links"></a></p>
<h3 id="links">Links</h3>
<p>Nützliche Links:</p>
<ul>
<li><a href="http://web.archive.org/web/20180602143516/https://www.freebsd.org/doc/handbook/bsdinstall-start.html" class="uri">http://web.archive.org/web/20180602143516/https://www.freebsd.org/doc/handbook/bsdinstall-start.html</a> Handbuch zu installation von FreeBSD (Achtung: Die Bilder sind etwas veraltert.).</li>
<li><a href="http://web.archive.org/web/20180602143507/https://www.freebsd.org/doc/handbook/svn.html" class="uri">http://web.archive.org/web/20180602143507/https://www.freebsd.org/doc/handbook/svn.html</a> Anleitung Komponenten wie <strong>ports</strong> oder <strong>src</strong> nachinstalliert.</li>
</ul>
<p><a id="freebsd-f%C3%BCr-lockdoc-vorbereiten"></a></p>
<h1 id="freebsd-für-lockdoc-vorbereiten">FreeBSD für LockDoc vorbereiten</h1>
<p>Damit LockDoc mit FreeBSD funktioniert, müssen noch ein paar Skripte und Programme installiert sowie Einstellungen vorgenommen werden.</p>
<p><a id="erforderliche-pakete-installieren"></a></p>
<h2 id="erforderliche-pakete-installieren">Erforderliche Pakete installieren</h2>
<p>Mit dem folgenden Befehl lassen sich als <strong>root</strong> alle notwendigen Programme installieren.</p>
<pre><code># pkg install &lt;paketname&gt;</code></pre>
<p>Für unser Setup wurden u.a. folgende Pakete installiert:</p>
<pre><code># pkg install vim mosh tmux git bash linux_base-c7-7.4.1708_6 sysbench-1.0.15 sudo clang80 gcc7-7.4.0_1 e2fsprogs-1.45.6_4</code></pre>
<p><strong>Achtung</strong> Ggf. muss der Versions-String für einzelne Pakete angepasst werden.</p>
<p><a id="userland-einrichten"></a></p>
<h2 id="userland-einrichten">Userland einrichten</h2>
<p>Analog zu Linux kann man einem Nutzer ermöglichen, root-Rechte zu erlangen. Hierzu muss der Nutzer Mitglied der Gruppe <code>wheel</code> sein.</p>
<pre><code>pw groupmod -m al -n wheel</code></pre>
<p>In <code>/usr/local/etc/sudoers</code> muss nun die Zeile <code>%wheel ALL=(ALL) ALL</code> auskommentiert werden.</p>
<p>Möchte man die Bash als Standardshell setzen, geht dies mit folgendem Befehl:</p>
<pre><code>chsh -s /usr/local/bin/bash</code></pre>
<p>Es empfiehlt sich dies ebenfalls als <code>root</code> zu tun.</p>
<p>Da manche Programme unter FreeBSD an anderer Stelle im Dateisystem als unter Linux liegen, erstellen wir Symlinks, damit dasselbe Benchmark-Skript nutzen können.</p>
<pre><code># ln -s /usr/local/bin/bash /bin/
# ln -s /usr/local/bin/sysbench /usr/bin/
# ln -s gcov7 /usr/local/bin/gcov</code></pre>
<p>Für den Linux-Kompatibilitätslayer sind Linux-spezifische Dateisysteme erforderlich. Diese müssen in der <code>/etc/fstab</code> eingetragen werden:</p>
<pre><code>linproc         /compat/linux/proc  linprocfs  rw,late  0       0
linsysfs        /compat/linux/sys   linsysfs        rw      0       0
tmpfs           /compat/linux/dev/shm  tmpfs   rw,mode=1777    0       0</code></pre>
<p>Die dafür nötigen Kernel-Module sollten automatisch geladen werden. Abschließend muss der Bootloader noch passend konfiguriert werden. Dazu trägt man folgenden Inhalt in <code>/boot/loader.conf</code> ein:</p>
<pre><code>kernel=&quot;lockdoc&quot;                        # Set FreeBSD&#39;s kernel as default
kernels_autodetect=&quot;YES&quot;                # Detect all installed kernels automatically
#console=&quot;vidconsole,comconsole&quot;        # Use video or video+com as console
console=&quot;vidconsole&quot;
vm.kmem_size=&quot;512M&quot;
vm.kmem_size_max=&quot;512M&quot;</code></pre>
<p>Damit man nicht an die Gerätenamen beim Einbinden von Partitionen gebunden ist, müssen Label gesetzt werden. Für die SWAP-Partition:</p>
<pre><code>swapinfo                # determine swap partition
glabel label swap /dev/vtbd0s1b     # Set label</code></pre>
<p>Außerdem muss die <code>/etc/fstab</code> noch angepasst werden. Dies kann z.B. so aussehen:</p>
<pre><code># Device        Mountpoint      FStype  Options Dump    Pass#
/dev/vtbd0s1a /               ufs     rw      1       1
/dev/label/swap none            swap    sw      0       0
linproc /compat/linux/proc linprocfs rw,late 0 0
linsysfs /compat/linux/sys linsysfs rw 0 0
tmpfs /compat/linux/dev/shm tmpfs rw,mode=1777 0 0</code></pre>
<p>Damit immmer das richtige rootfs genutzt wird:</p>
<pre><code>mount                           # Get root partition
dumpfs -l /dev/vtbd0s1a                 # Get UFS id, e.g., /dev/ufsid/5fa7141d81b1911d
vfs.root.mountfrom=&quot;ufs:/dev/ufsid/5fa7141d81b1911d&quot;    # Use labels to detects the rootfs. Enables easy switching of disk technologies, e.g. scsi, ide, or virtio</code></pre>
<p><a id="userland-compilieren"></a></p>
<h2 id="userland-aus-dem-repository-installieren">Userland aus dem Repository installieren</h2>
<p>Es ist nicht ganz klar, ob der Schritt wirklich nötig ist. Es gibt aber Berichte, dass FreeBSD sich komisch verhalten kann, wenn Kernel und Userland nicht auf derselben Version basieren. Installiert wird in dieser Anleitung ein FreebSD 12.4. Der Kernel-Tree ist aber in Version 13.0-current. Daher muss das Userland aus dem Tree gebaut werden. Eine detailierte Anleitung, wie man das Userland aktualisiert, findet sich <a href="https://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/makeworld.html">hier</a>.</p>
<pre><code>chmod g+w /usr/obj          # FreeBSD places object files during userland build here. Make it writeable for members of group wheel
cd /opt/kernel/freebsd/src/
make -j4 buildworld
make -j4 kernel
shutdown -r now
cd /opt/kernel/freebsd/src
sudo make installworld
sudo mergemaster -Ui
shutdown -r now
</code></pre>
<p><a id="installation-des-init-skripts"></a></p>
<h2 id="installation-des-init-skripts">Installation des Init-Skripts</h2>
<p>Die Skripte finden sich im tools-Repo unter <code>manuals/vm-freebsd-32/scripts</code>. Diese müssen in die VM nach <code>/lockdoc</code> kopiert werden. Anschließend muss das neue Init-Skript im Bootloader vermerkt werden. Hierzu muss folgende Zeile in die Datei <code>/boot/loader.conf</code> eingetragen werden: Da das ZFS-Dateisystem für <code>/home</code> einen separaten Pool anlegt, der zum Startzeitpunkt noch nicht eingehängt ist, muss das Init-Skript im root-Dateisystem liegen.</p>
<pre><code>init_script=&quot;/lockdoc/boot.init.sh&quot;     # Hook in our own init script to automatically start the benchmark</code></pre>
<p>Ggf. sind die Zeilen, die ebensfalls <code>init_script</code> setzen, auszukommentieren. Jetzt wird bei jedem Start, nachdem der Kernel geladen wurde, als erstes dieses Script ausgeführt. <strong>Achtung:</strong> Sollte der Nutzer <strong>nicht</strong> <code>al</code> lauten, müssen die Init-Skripte angepasst werden. Sollte der Nutzer beim Startet <strong>nicht</strong> innerhalb von fünf Sekunden einen beliebigen Buchstaben drücken, wird der Benchmark gestartet. Andernfalls wird das gewöhnliche FreeBSD-Userland gestartet.</p>
<p><a id="installation-des-benchmark-skripts"></a></p>
<h2 id="installation-des-benchmark-skripts">Installation des Benchmark-Skripts</h2>
<p>Das Skript <code>run-bench.sh</code> befindet sich im tools-Repo unter <code>manuals/vm-linux-32/scripts</code>. Dies muss in der VM nach <code>/lockdoc</code> kopiert werden. Zusätzlich muss das Verzeichnis <code>/lockdoc/bench-out</code> angelegt werden und aus <code>manuals/vm-linux-32/scripts</code> die Datei <code>fork.c</code> dahin kopiert werden.</p>
<p><a id="installation-der-benchmark-tools"></a></p>
<h2 id="installation-der-benchmark-tools">Installation der Benchmark-Tools</h2>
<p>Sowohl in der Linux- als auch in der FreeBSD-VM verwenden wir ein Subset des Linux-Test-Project (LTP) für unsere Benchmarksuite. Der Quellcode findet sich unter <code>https://github.com/linux-test-project/ltp.git</code>. Aktuell setzen wir Revision <code>a6a5caef</code>, Tag/Release <code>20190115</code>, ein. Mit Hilfe des Linux-Kompatibilitätslayers laufen die Programme aus dem LTP problemlos unter FreeBSD. Allerdings müssen sie unter Linux übersetzt und in das Verzeichnis <code>/compat/linux/opt/kernel/ltp/bin</code> installiert werden. Vor dem Übersetzen müssen noch die Dateien <code>{syscalls,{syscalls,fs}-custom}</code> aus <code>manuals/vm-linux-32/scripts/</code> nach <code>$LTPSRC/runtest/</code> kopiert werden.</p>
<p><a id="konfiguration-und-%C3%9Cbersetzen-des-freebsd-kernels"></a></p>
<h2 id="konfiguration-und-übersetzen-des-freebsd-kernels">Konfiguration und Übersetzen des FreeBSD Kernels</h2>
<p>Zuerst muss unsere eigene Version des FreeBSD-Trees ausgechecked werden. Wir verwenden einen bestimmten Branch.</p>
<pre><code>git clone git@gitos.cs.tu-dortmund.de:lockdoc/freebsd.git -b releng/12.0-lockdoc /opt/kernel/freebsd/src</code></pre>
<p>** Achtung: ** Bevor irgendein selbstgebauter Kernel installiert wird, sollte der Standard-Kernel gesichert werden:</p>
<pre><code>sudo cp -r /boot/kernel /boot/kernel.ori</code></pre>
<p>Bei einem <code>make install</code> wird der aktuelle Kernel nach <code>/boot/kernel.old</code> kopiert und der neue Kernel in <code>/boot/kernel</code> installiert. <a id="konfiguration-1"></a></p>
<h3 id="konfiguration-1">Konfiguration</h3>
<p>Die Konfiguration für LockDoc befindet sich bereits in <code>/opt/kernel/freebsd/src/sys/i386/conf</code>. Daher ist nichts weiter zu tun, sofern diese Konfiguration verwendet werden soll.</p>
<p>Alternativ kann auch mit einer Standard-Konfiguration begonnen werden:</p>
<pre><code># cd /opt/kernel/freebsd/src/sys/i386/conf
# cp GENERIC LOCKDOC</code></pre>
<p>Danach kann die Konfiguration angepasst werden, um z.B. einige Sub-Systeme zu entfernen.</p>
<p><a id="%C3%9Cbersetzen-au%C3%9Ferhalb-des-source-trees"></a></p>
<h3 id="übersetzen-außerhalb-des-source-trees">Übersetzen außerhalb des Source-Trees</h3>
<p>Damit wirklich nur der Kernel übersetzt wird und nicht noch Abhängigkeiten aus dem FreeBSD-Tree, kann man mit einer Konfiguration einen spezialisierten Source-Tree erzeugen und diesen anschließend übersetzen:</p>
<pre><code># cd /opt/kernel/freebsd/src/sys/i386/conf
# config -d /opt/kernel/freebsd/obj -I `pwd` `pwd`/LOCKDOC
# cd /$OBJDIR
# MODULES_OVERRIDE=&quot;&quot; make [-j X]
# sudo -E MODULES_OVERRIDE=&quot;&quot; KODIR=/boot/lockdoc make install</code></pre>
<p>Es ist wichtig, die Variable <code>MODULES_OVERRIDE=""</code> zu setzen. Nur so wird verhindert, dass alle Module gebaut werden - was das Standard-Verhalten ist. Effektiv werden gar keine separaten Kernel-Module gebaut. Alle erforderlichen Treiber und co. werden über die Konfiguration in das Kernel-Image gelinkt. Durch die Variable <code>KODIR</code> teilt man dem Makefile mit, dass der Kernel in <code>/boot/lockdoc</code> installiert werden sollen. Nur wenn den Kernel in dieses Verzeichnis installiert, wird er auch automatisch durch den Bootloader ausgewählt (siehe <code>kernel="..."</code> in <code>/boot/loader.conf</code>). Sollte beim Übersetzen eine Fehlermeldung (<code>line 127: amd64/arm64/i386 kernel requires linker ifunc support</code>) erscheinen, die den Linker nennt, hilft evtl. das Setzen der Variable <code>LD=""</code>: <code>MODULES_OVERRIDE=""  LD=ld.lld make [-j X]</code>.</p>
<p><a id="%C3%9Cbersetzen-im-source-tree"></a></p>
<h3 id="übersetzen-im-source-tree">Übersetzen im Source-Tree</h3>
<p>Möchte man einfach den Kernel innerhalb des FreeBSD-Trees bauen, genügen folgende Befehle:</p>
<pre><code># cd /usr/src
# make buildkernel KERNCONF=LOCKDOC
# make installkernel KERNCONF=LOCKDOC</code></pre>
<p>Außerdem kann mit dem Flag <code>-DKERNFAST</code> das Übersetzen beschleunigt werden, in dem nur die Übersetzungseinheiten neu gebaut werden, deren Konfiguration oder Quellcode sich geändert hat.</p>
<pre><code># cd /usr/src
# make buildkernel -DKERNFAST KERNCONF=LOCKDOC
# make installkernel KERNCONF=LOCKDOC</code></pre>
<p><a id="links-1"></a></p>
<h2 id="links-1">Links</h2>
<ul>
<li><a href="http://web.archive.org/web/20180602150338/https://www.freebsd.org/doc/handbook/kernelconfig-config.html">ausführliche Anleitung zur Konfiguration des Kernels</a></li>
<li><a href="http://web.archive.org/web/20180602152745/https://www.freebsd.org/doc/handbook/kernelconfig-building.html">ausführliche Anleitung zur Übersetzung des Kernels</a></li>
</ul>
<p>&lt;a id="freebas-code-abdeckung"</a></p>
<h1 id="code-abdeckung">Code-Abdeckung</h1>
<p><a id="freebsd-code-abdeckung-bestimmen-kcov"></a></p>
<h2 id="code-abdeckung-bestimmen---kcov">Code-Abdeckung bestimmen - KCOV</h2>
<p>Zunächst müssen die passenden Kernel gebaut werden. Um einen Kernel mit KCOV-Unterstützung zu bauen, sind folgende Befehle nötig:</p>
<pre><code># cd /opt/kernel/freebsd/src/sys/i386/conf
# config -d /opt/kernel/freebsd/obj-kcov -I `pwd` `pwd`/LOCKDOC_KCOV
# MODULES_OVERRIDE=&quot;&quot; make [-j X]
# sudo -E MODULES_OVERRIDE=&quot;&quot; KODIR=/boot/lockdoc-kcov make install</code></pre>
<p>Außerdem müssen die folgenden zwei Headerdateien in das System-Include-Verzeichnis kopiert werden, damit <code>kcovtrace</code> übersetzt werden kann:</p>
<pre><code># cp /opt/kernel/freebsd/src/sys/sys/kcov.h /usr/include/sys/
# cp /opt/kernel/freebsd/src/sys/sys/coverage.h /usr/include/sys/
# clang80 -o kcovtrace kcovtrace.c</code></pre>
<p>Das Übersetzen mit dem <code>clang</code> geht nur, wenn es nicht für i386 übersetzt wird. Ansonsten muss der GCC genommen werden:</p>
<pre><code># gcc7 -march=i586 -o kcovtrace kcovtrace.c</code></pre>
<p><code>kcovtrace</code> muss als <code>root</code> ausgeführt werden.</p>
<pre><code># GATHER_COV=1 ./kcovtrace /lockdoc/run_bench.sh &lt;benchmark&gt; 2&gt; pcs.txt</code></pre>
<p>Achtung ggf. veraltet, da nicht mehr gepflegt: Um einen Kernel mit GCOV-Unterstützung zu bauen, sind folgende Befehle nötig:</p>
<pre><code># cd /opt/kernel/freebsd/src/sys/i386/conf
# config -d /opt/kernel/freebsd/obj-gcov -I `pwd` `pwd`/LOCKDOC_GOV
# MK_FORMAT_EXTENSION=no MODULES_OVERRIDE=&quot;&quot; LD=ld.lld CC=gcc7 COMPILER_TYPE=gcc make [-j X]
# sudo -E MODULES_OVERRIDE=&quot;&quot; KODIR=/boot/lockdoc-gcov LD=ld.lld make install</code></pre>
<p>Achuntg: Damit das Setzen der Umgebungsvariable, wie unten, korrekt funktioniert sollte als Standardshell für <code>root</code> die Bash eingestellt sein. <a id="freebsd-code-abdeckung-bestimmen-gcov"></a></p>
<h2 id="code-abdeckung-bestimmen---gcov">Code-Abdeckung bestimmen - GCOV</h2>
<p>Zunächst das Linux-DebugFS einhängen:</p>
<pre><code># mount -t debugfs debugfs /mnt</code></pre>
<p>GCOV muss zunaechst mindestens einmal aktiviert werden. Andernfalls existiert das Verzeichnis <code>/mnt/gcov</code> nicht und das Skript <code>gcov-trace.sh</code> bricht ab.</p>
<pre><code># sysctl debug.gcov.enable=1</code></pre>
<p>Die Variable <code>GATHER_COV</code> sorgt dafür, dass das Skript <code>run-bench.sh</code> gewisse Initialisierungsbefehle auslässt. Der erste Parameter von <code>./gcov-trace.sh</code> gibt an, wo der Kernel übersetzt wurde - hier <code>/opt/kernel/freebsd/obj-gcov/</code>. Der dritte Parameter gibt den Namen der Ausgabedatei an.</p>
<pre><code># GATHER_COV=1 GCOV_DIR=/mnt/gcov ./gcov-trace.sh /opt/kernel/freebsd/obj-gcov/ test /lockdoc/run_bench.sh &lt;benchmark&gt;</code></pre>
<p><a id="freebsd-code-abdeckung-links"></a></p>
<h2 id="links-2">Links</h2>
<ul>
<li><a href="https://01.org/linuxgraphics/gfx-docs/drm/dev-tools/gcov.html#">GCOV on Linux</a></li>
<li><a href="https://01.org/linuxgraphics/gfx-docs/drm/dev-tools/gcov.html#appendix-b-gather-on-test-sh">Gather GCOV files on test machine</a></li>
</ul>
<p>Written by Daniel Korner 2018; extended by Alexander Lochmann 2018</p>
</body>
</html>

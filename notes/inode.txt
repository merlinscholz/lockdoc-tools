- i_lock: i_count, 
- i_mode:
	+ r-Zugriffe ohne Lock passieren meist auf die höherwertigen Bits, wo statische Information wie IS_BLKDEV oder IS_DIR abgelegt werden
	+ w-Zugriffe ohne Lock passieren meist aus einem Kontext, wo die Inode noch nicht global zur Verfügung steht, wie z.B. inode_init_owner, alloc_anon_inode, mount_pseudo
- i_flags:
	+ Soll wohl irgendwann mal mit i_lock abgesichert werden:
		In the long run, i_mutex is overkill, and we should probably look at using the i_lock spinlock to protect i_flags, and then make sure it is so documented in include/linux/fs.h and that all code follows the locking convention!! (http://lxr.free-electrons.com/source/fs/inode.c?v=3.16#L1923)
- Per default enthält eine Inode bereits eine Instanz von 'struct adress_space' (i_data). 
  Nach Allokation zeigt i_mapping per default auf die eingebettete Instanz. Daher können
  indirekt Zugriffe auf i_data stattfinden, wenn z.B. im Quellcode nur inode->i_mapping steht.


#!/bin/bash
# Extract all commandline expressions containing counterexample.sql.sh from INPUTFILE for a given data type.
# The input file should contain the output produced by './hypothesizer --bugsql'.
# Afterwards, all commandline expressions are executed, and its output is concatenated in one file. That file now contains
# all sql statements to find all counterexamples for a given data type.
# If a database is provided, the script automatically executes the queries.

if [ ${#} -lt 3 ]; then
	cat >&2 <<-EOT
	usage: $0 INPUTFILE DATATYPE OUTPUTFILE [DATABASE]

	INPUTFILE       Input file as generated by './hypothesizer --bugsql'
	DATATYPE        data type
	OUTPUTFILE      Output file
	DATABASE        the database where to execute the query
	VMLINUX         The vmlinux image to resolve the instruction pointers to code positions
	EOT
	exit 1
fi

DIR=`dirname ${0}`
INPUTFILE=${1}; shift
DATATYPE=${1}; shift
OUTPUT=${1}; shift
DATABASE=${1}; shift
VMLINUX=${1}; shift
COUNTEREXAMPLE_SH="counterexample.sql.sh"
QUERY_FILE=$(mktemp /tmp/counter-examples-sql.XXXXXX)
RESULTS=$(mktemp /tmp/counter-examples-results.XXXXXX)
DELIMITER=";"

echo -n "" > ${QUERY_FILE}
echo -n "" > ${RESULTS}

if [ ${DATATYPE} == "any" ];
then
	GREP_REGEX=""
else
	GREP_REGEX="${COUNTEREXAMPLE_SH} ${DATATYPE}"
fi

COUNT=0
grep "^\![[:space:]]*${COUNTEREXAMPLE_SH}" ${INPUTFILE} | sed -e "s/^\![ \t]*//" | grep "${GREP_REGEX}" | while read cmd;
do
	echo "Running: ${cmd}:"
	eval ${DIR}/../queries/$cmd > ${QUERY_FILE}
	if [ ! -z ${DATABASE} ];
	then
		echo "Running query..."
		if [ ${COUNT} -gt 0 ];
		then 
			mysql ${DATABASE} < ${QUERY_FILE} | tr '\t' "${DELIMITER}" | sed '/data_type;member;accesstype;fn;instrptr;stacktrace_id;locks_held;occurrences/d' >> ${RESULTS}
		else
			mysql ${DATABASE} < ${QUERY_FILE} | tr '\t' "${DELIMITER}" >> ${RESULTS}
		fi
		if [ ${?} -ne 0 ];
		then
			echo "Error running query from ${QUERY_FILE}" >&2
			exit 1
		fi
	fi
	let COUNT=COUNT+1
done;
rm "${QUERY_FILE}"

COUNT=0
echo -n "" > ${OUTPUT}
while read line
do
	if [ ${COUNT} -eq 0 ];
	then
		let COUNT=COUNT+1
		echo ${line}${DELIMITER}"fileline" >> ${OUTPUT}
		continue
	fi
#	echo $line
	INSTRPTR=`echo ${line} | cut -d ${DELIMITER} -f 5`
	POS=`addr2line -e ${VMLINUX} ${INSTRPTR}`
	echo ${line}${DELIMITER}${POS} >> ${OUTPUT}
	let COUNT=COUNT+1
done < ${RESULTS}
rm "${RESULTS}"
